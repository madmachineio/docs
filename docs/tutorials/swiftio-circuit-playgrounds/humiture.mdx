---
title: Temperature and humidity measurement
description: Learn how to
---

# Temperature and humidity measurement

Whatâ€™s the current temperature in your place? Maybe you want to check the weather forecast. In this tutorial, you could get the reading using your board and a temperature and humidity sensor. 
 
**Learning goals**
* Roughly understand the I2C communication.
* Learn about the data system: hexadecimal, binary and decimal.
* Know how to use I2C to communicate with the sensor.
* Learn to use libraries to simplify your coding process.

## ðŸ”¸Background

### What is I2C?


So far you have learnt simple input and output. It allows you to read or set the voltage on specified pins to communicate with some components, e.g. the LED needs true (1) to be on and false (0) to be off, the button reads true if pressed and false if release. However there are much more advanced devices which involves tons of data, it would be an enormous project to manually control the signal. Luckily, you can use different communication protocols to work with them. 

The **communication protocols**  are a set of widely accepted rules to decide how the devices communicate with each other. They specify the details to transmit and interpret data, including message format, error detection, etc. All devices that adopt the same protocol can understand each other and start communications. It's quite like various language in our life, only the persons who speak the same language can know what's talking.

So in the following chapters, letâ€™s dive into some common communication protocols in microcontroller world. In this tutorial, you are going to learn about I2C.

**I2C Introduction**

**Inter-integrated circuit**, I2C (I two C or I squared C) for short, is one of the protocols that is suitable for short-distance communication. It allows multiple slave devices to communicate with one master device using merely two wires, which constitutes its huge advantage compared to other protocols. 

The two wires contain a SCL and a SDA line. 
* **SCL (serial clock)** carries the clock signal generated by the master device. With a preset speed, the devices know the time for each transmission and can infer if it completes. Thus, it ensures synchronous data transmission between devices. 
* **SDA (serial data)** is the data line. Both master and slave devices will send data on this line. The data is usually in bytes.

<img
  src={require('./img/I2C.png').default}
  alt="I2C" width="480"
/>

**Master and slave device**

Master device controls the communication process. It decides when the transmission starts and ends. Slave devices would respond to the master device. Usually, there could only one master device but mutiple slave devices. Your SwiftIO Feather board will always serve as master device, and the other I2C devices connected serve as slave devices.

**Address**

Why could only two wires support multiple devices without confusion? This is because each I2C device has its unique address. It's usually decided when designing the hardware and will be written on its datasheet. At the beginning of the communication, master device will send the address of the device that is wanted. Only the corresponding device would respond and prepare for the following process. Thus there wouldn't be confusion among different devices.

<img
  src={require('./img/i2cAddress.png').default}
  alt="I2C address" width="480"
/>

:::note
Some devices may have several address options in case the devices you use happen to share the same address.
:::

**Data transmission**

Each communication protocol has its own data transmission rules. These rules define how and when the data is transmitted one after another, how the voltage level changes during communication. If you want to know the details, you can read [this article](https://www.analog.com/en/technical-articles/i2c-primer-what-is-i2c-part-1.html).

The SwiftIO library has already abstracted all stuff. Therefore, you can use I2C communication easily. In brief, you need the device address, followed by the data to be sent or the buffer to store the reading values. Later you will see an example to understand it better.




## ðŸ”¸New component

### Sensor

First, letâ€™s take a quick look at sensors. 

Sensors are devices sensitive to natural properties or environmental changes, like temperature, sound, pressure, light, movement, etc. They can convert these physical inputs into electrical signals for the microcontroller. 

In short, almost all sensors represent the measured data in the form of voltage. Finally, the voltage values will be decoded to corresponding physical values, like temperature, distance, light intensity, etc.

Depending on the output value, sensors can be divided into analog and digital sensors.

* Analog sensors will give analog values, like potentiometers. There are also many common analog sensors, like light sensor, temperature sensor, sound sensor, etc. This kind of sensor needs ADC to get readings but would be easier to use.

* Digital sensors will produce digital readings of ones and zeros, like buttons (on or off). For many more advanced digital sensors, they actually read analog values in the beginning and then convert them to digital values using built-in ADC, thus you can find both digital and analog temperature sensors.

Nowadays, more and more digital sensors are used. They contain all stuff on a single chip and may support one or more communication protocols. They ensure more accuracy and provide more functionalities.


### Humiture sensor

Humiture sensor allows you to measure both the temperature and humidity. There are different types of sensors that allows you to read temperature. SHT3x is one kind of digital temperature and humidity sensor and uses I2C to communicate with the microcontroller. It can give you a more accurate readings.

The sensor contains components sensitive to temperature and humidity, which will lead to corresponding voltage values in the circuit during measurement. Then it will give you raw values after calibration. You could use the formula provided on its datasheet to get temperature in Celsius and relative humidity in percentage.



## ðŸ”¸New concept

### Number system

The number system is the way used to represent the number. The Decimal number system (base-10) is what you are familiar with. It is based on ten symbols, 0 to 9, and is what you always use in everyday life. Besides, there are two more important systems in the microcontroller world.

Binary is the base-2 number system. The data will always start  with 0b. The two digits 0 and 1 are used to represent all numbers. This is how the data is stored on your computer. For a binary number, each digit is called a bit. A byte consists of 8 bits.  

Hexadecimal is the base-16 number system. The data always starts with 0x. It used 16 symbols, digits 0 to 9, and letters A to F to represent all numbers. A to F is equivalent to 10 to 15 respectively. Hexadecimal provides a more convenient way to represent those long binaries. 

These three kinds of numbers could be converted to either one. The following chart shows how the numbers from 0 to 15 are represented in binary and hexadecimal. 

<img
  src={require('./img/numberSystem.png').default}
  alt="binary and hexadecimal table" width="240"
/>

## ðŸ”¸Circuit
The humiture is connected to I2C0.

<img
  src={require('./img/humitureCircuit.png').default}
  alt="Humiture module circuit" width="960"
/>

<img
  src={require('./img/humitureCircuitDiagram.png').default}
  alt="Humiture module circuit diagram" width="360"
/>

:::note
The circuits above are simplified for your reference.
:::


## ðŸ”¸Preparation

### Overview 
The sensor used here is SHT3x. You could find its datasheet by searching on the Internet. The datasheet lists all the data needed. 

Each time you use the sensor, just find the command in it, send the corresponding data to communicate with the sensor. These commands for each sensor are determined, and it is annoying to check the datasheet every time you use it. 

So usually, a library, aka the device driver, would be used to cover all the common usages of each type of sensor, and then provide you with simple APIs. In this way, you could directly invoke the methods in the library instead of referring to the long datasheet.

Well, take the library SHT3x for example, letâ€™s see how the I2C is used. As always, here you will find related APIs for this project.

### Class
I2C: this class controls the I2C communication between the board and the sensors. The data you are going to deal with using I2C is always 8-bit long.
Method
write(_:to:)
Write data to the slave device. The first parameter is the data that is going to be sent to the slave. The second one needs the device address.
read(count:from:)
Read data from the slave device. The first parameter defines the number of 8-bit data you would get. The second one is the device address.


### Know about details 

Letâ€™s look at each part of the library in detail. Here is the library source code: https://github.com/madmachineio/MadDrivers/blob/main/Sources/SHT3x/SHT3x.swift. 

```swift
import SwiftIO
```
Import the SwiftIO library to read or write data.

```swift
class SHT3x {
}
```

This class groups all the common usages related to the sensor. It has the keyword class and the library name SHT3x. 

```swift
let i2c: I2C
let address: UInt8
```

The variable or constant inside a class is called property. They must be initialized with a value.

You could notice two properties here: i2c and address. They donâ€™t have an initial value and thus need an initializer.

```swift
init(_ i2c: I2C, address: UInt8 = 0x44) {
    self.i2c = i2c
    self.address = address
    reset()
}
```

The initializer is a special kind of function. It allows you to assign values to the properties, as well as perform other setups when creating an instance. 

This initializer takes the two required parameters. The first one of course is the I2C interface. The address of this sensor is always the same and has a default value. So you donâ€™t need to pass the value to it as initialization.

You could notice the parameter names are the same as the property names. self is used to refer to the instance itself. Then use the dot syntax to access the property. So the value of the property is set to the value of parameter.

When you want to use a method inside the class, you could directly invoke it instead of dot syntax, as the method reset here. After initializing a new instance, the I2C interface is ready and the sensor will be reset.

```swift
func readCelsius() -> Float { 
}
```

You could use it to get the temperature in Celsius. Inside the method, you make the sensor start to measure. The value obtained from the sensor is a raw value. It needs to be calculated to the temperature value according to the formula in the data sheet.

The other two instance methods readFahrenheit, readHumidity are similar.

```swift
extension SHT3x {
}
```

Extension is used to add new functionalities to the class. One of its characteristics is to organize your code and group different parts of code.

In this extension, you could find some predefined methods related to the sensor. Then the basic functionalities - initialize the sensor, get the final results - are listed in the class above.

```swift
enum Command: UInt16 {
    case readStatus = 0xF32D
    ...
}
```

Enumeration, usually called enum, is a group of related values. It starts with the keyword enum, followed by enumeration name. Inside the curly brackets, you put a series of cases. Each case could be attached to a value.
The enum Command contains the data for each command according to the datasheet for easier reference. 

```swift
func writeCommand(_ command: Command) {

}
```

Since the data of this sensor is represented in 16-bit, whereas I2C communication uses 8-bit data. This method is used to separate the 16-bit data into two 8-bit data by using a bitwise operation, then send the data via the I2C bus.

```swift
func startMeasure() -> (rawTemp: UInt16, rawHumi: UInt16) {

}
```

This method is about the measurement: 

1. Use the suitable command listed in the enum, send the data to the sensor using  writeCommand.
2. Then wait for a while to allow the sensor to sense the environment. 
3. Read data from the sensor. The sensor would send 6 bytes back to the board. 
4. The first two data are the values for temperature. The 4th and 5th are the values for humidity. Merge each two 8-bit values into 16-bit data. And return the raw temperature and humidity values.



:::note
Some bitwise operations are used in the data calculation: 

| Symbol | Meaning| Diagram |
|--------|---------|---------|
| << | left shift: all bits will move to the left, and 0 will be added to the empty bits on the right. | <img src={require('./img/leftShift.png').default} alt="Left shift" width="480"/> |
| >> | right shift: all bits will move to the right, and 0 will be added to the empty bits on the left. | <img src={require('./img/rightShift.png').default} alt="Right shift" width="480"/> |
| & | bitwise AND operator: it will calculate each corresponding bit of two data. Only if both two bits are 1, the result will be 1, or it will be 0. | <img src={require('./img/and.png').default} alt="And operator" width="480"/> |
| \| | bitwise OR operator: it will calculate each corresponding bit of two data. If either of the bits is 1, the result will be 1. | <img src={require('./img/or.png').default} alt="Or operator" width="480"/> |


Take the operation in writeCommand for example:

```swift
UInt8(value >> 8)
```

The value is 16-bit. In the first operation, the bits will move to the right at first. So the original 8 bits on the right are discarded. In the new data, the 8 bits on the right are replaced by the original 8 bits on the left. The empty 8 bits on the left are completed with 0. After its type is changed to UInt8, leave the original 8 bits on the left.

```swift
UInt8(value & 0xFF)
```

The second does bitwise AND operation with 0xFF (1111 1111). So the right 8 bits would be the same as those of the original data. After it is changed to UInt8, leave the original 8 bits.
:::


If you do not quite understand the code above, donâ€™t worry. This library is provided in the project and you just need to import it. Here, we just want you to get more familiar with I2C communication in actual projects. 
With the existing libraries, things are much easier. However, writing libraries is not an easy task - you need to consult the datasheet to transmit the data, to configure the device. So you may not do it at the very start. 


## ðŸ”¸Exercise
1. Read temperature and humidity

### 1. Read temperature and humidity

Letâ€™s use the humiture to get the temperature and humidity. As you download the code, the sensor begins to work and you can see the value printed on the serial monitor. The value slightly changes. If you put your finger next to the sensor, the temperature will increase.

**Example code**

```swift
// Of course, you need to import the SwiftIO and SwiftIOFeather. Import the SHT3x to directly read values. 
import SwiftIO
import SwiftIOFeather
import SHT3x

// Initialize the I2C interface. And use it to initialize the sensor.
let i2c = I2C(Id.I2C0)
let sht = SHT3x(i2c)

// Read the temperature and humidity. Print their values out. Stop for 1s and repeat it.
while true {
    let temp = sht.readCelsius()
    let humidity = sht.readHumidity()
    print("Temperature: \(temp)C")
    print("Humidity: \(humidity)%")
    sleep(ms: 1000)
}
```



**Code analysis**

```swift
import SHT3x
```
MadDrivers contains several libraries about different devices and has been added to your project by default. SHT3x is one of them. So you just need to import it.

```swift
print("Temperature: \(temp)C")
print("Humidity: \(humidity)%")
```

Print the value out. 

The content is represented as a string, so you add double quotation marks. 

Besides, the value is a constant, so you will need string interpolation to combine them together. You will add its name as a placeholder after a backslash and between a pair of parentheses. And it will be replaced by its exact value.
 

## ðŸ”¸More info

* [I2C](https://www.analog.com/en/technical-articles/i2c-primer-what-is-i2c-part-1.html)
* [Number system conversion](https://code.tutsplus.com/articles/number-systems-an-introduction-to-binary-hexadecimal-and-more--active-10848)