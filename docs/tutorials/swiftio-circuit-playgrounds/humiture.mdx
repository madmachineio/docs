---
title: Temperature and humidity measurement
description: Learn how to
---

# Temperature and humidity measurement

You’ll get the current temperature and humidity in your room.

What’s the current temperature in your place? Are you checking the weather forecast now? There is another choice - you could get what you want using the microcontroller and the sensor that is used to measure both the temperature and humidity. 
 
**Learning goals**
* Roughly understand the I2C communication.
* Learn about the data system: hexadecimal, binary and decimal.
* Know how to use I2C to communicate with the sensor.
* Learn to use the library to simplify your coding process.

## Background

### What is I2C?

Well, in the previous chapters, you get to know simple input and output. You read or set the voltage in the specified pin. The communication protocols also deal with digital input and output. But they follow some widely predefined rules to transmit data and interpret data. So in the following chapters, let’s go more into the communication protocols. In this project, you are going to learn about I2C.

**Introduction**

Inter-integrated circuit, I2C (I two C or I squared C) for short, is one of the protocols that is suitable for short-distance communication. It allows multiple slave devices to communicate with one master device using merely two wires, which constitutes its huge advantage compared to other protocols. 

The two wires contain SCL and SDA lines. SCL (serial clock) carries the clock signal generated by the master. With a preset speed, the devices know the time used to transmit each bit and could predict if the data transmission is completed. Thus, it ensures synchronous data transmission between devices. SDA (serial data) is the data line. All the data is transferred on this line by master or slave devices. And the data is usually in bytes.

**Master and slave device**

Master device controls the communication process. It decides when the transmission starts and ends. Slave devices would respond to the master when it’s called. In our situation, the master is always the SwiftIO Feather board. And the other I2C devices connected serve as slaves.

**Address**

Why could only two wires support multiple devices without confusion?

This is because each I2C device has its unique address. You could always find it in its datasheet. At the beginning of the communication, the master will send the address of the device that is wanted. Only the corresponding device would respond and prepare for the following process. Thus there won’t be confusion among different devices.

**Data transmission**

Each communication protocol has its own data transmission rules. These rules define how the data is transmitted one after another, how the voltage level changes during communication. 

As you deal with it, in brief, you just need to send the device address, as well as the data of the command listed in the datasheet to read or write data. Later you will see an example to better understand it.




## New component

### Humiture sensor

First, let’s take a quick look at sensors. Sensors are devices that are sensitive to a physical phenomenon or environmental changes, like temperature, sound, pressure, light, etc. No matter what their function, they detect these physical inputs and then turn them into electrical signals that could  be read by the microcontroller.
Now back to the humiture sensor. It could measure the temperature and humidity. 

The component to measure the temperature is certainly sensitive to the temperature. Its resistance would change with the temperature, which will then change the voltage.

The other one for humidity could measure the relative humidity, that is, the amount of water vapor in the air. Different humidity of the air will lead to corresponding voltage in the circuit.

This sensor uses I2C to communicate with the microcontroller. You will know how it works later in more detail.

## New concept

### Number system

The number system is the way used to represent the number. The Decimal number system (base-10) is what you are familiar with. It is based on ten symbols, 0 to 9, and is what you always use in everyday life. Besides, there are two more important systems in the microcontroller world.

Binary is the base-2 number system. The data will always start  with 0b. The two digits 0 and 1 are used to represent all numbers. This is how the data is stored on your computer. For a binary number, each digit is called a bit. A byte consists of 8 bits.  

Hexadecimal is the base-16 number system. The data always starts with 0x. It used 16 symbols, digits 0 to 9, and letters A to F to represent all numbers. A to F is equivalent to 10 to 15 respectively. Hexadecimal provides a more convenient way to represent those long binaries. 

These three kinds of numbers could be converted to either one. The following chart shows how the numbers from 0 to 15 are represented in binary and hexadecimal. 

## Circuit
The humiture is connected to I2C0.


:::note
The circuits above are simplified for your reference.
:::


## Preparation

### Overview 
The sensor used here is SHT3x. You could find its datasheet by searching on the Internet. The datasheet lists all the data needed. 

Each time you use the sensor, just find the command in it, send the corresponding data to communicate with the sensor. These commands for each sensor are determined, and it is annoying to check the datasheet every time you use it. 

So usually, a library, aka the device driver, would be used to cover all the common usages of each type of sensor, and then provide you with simple APIs. In this way, you could directly invoke the methods in the library instead of referring to the long datasheet.

Well, take the library SHT3x for example, let’s see how the I2C is used. As always, here you will find related APIs for this project.

### Class
I2C: this class controls the I2C communication between the board and the sensors. The data you are going to deal with using I2C is always 8-bit long.
Method
write(_:to:)
Write data to the slave device. The first parameter is the data that is going to be sent to the slave. The second one needs the device address.
read(count:from:)
Read data from the slave device. The first parameter defines the number of 8-bit data you would get. The second one is the device address.


### Know about details 

Let’s look at each part of the library in detail. Here is the library source code: https://github.com/madmachineio/MadDrivers/blob/main/Sources/SHT3x/SHT3x.swift. 

```swift
import SwiftIO
```
Import the SwiftIO library to read or write data.

```swift
class SHT3x {
}
```

This class groups all the common usages related to the sensor. It has the keyword class and the library name SHT3x. 

```swift
let i2c: I2C
let address: UInt8
```

The variable or constant inside a class is called property. They must be initialized with a value.

You could notice two properties here: i2c and address. They don’t have an initial value and thus need an initializer.

```swift
init(_ i2c: I2C, address: UInt8 = 0x44) {
    self.i2c = i2c
    self.address = address
    reset()
}
```

The initializer is a special kind of function. It allows you to assign values to the properties, as well as perform other setups when creating an instance. 

This initializer takes the two required parameters. The first one of course is the I2C interface. The address of this sensor is always the same and has a default value. So you don’t need to pass the value to it as initialization.

You could notice the parameter names are the same as the property names. self is used to refer to the instance itself. Then use the dot syntax to access the property. So the value of the property is set to the value of parameter.

When you want to use a method inside the class, you could directly invoke it instead of dot syntax, as the method reset here. After initializing a new instance, the I2C interface is ready and the sensor will be reset.

```swift
func readCelsius() -> Float { 
}
```

You could use it to get the temperature in Celsius. Inside the method, you make the sensor start to measure. The value obtained from the sensor is a raw value. It needs to be calculated to the temperature value according to the formula in the data sheet.

The other two instance methods readFahrenheit, readHumidity are similar.

```swift
extension SHT3x {
}
```

Extension is used to add new functionalities to the class. One of its characteristics is to organize your code and group different parts of code.

In this extension, you could find some predefined methods related to the sensor. Then the basic functionalities - initialize the sensor, get the final results - are listed in the class above.

```swift
enum Command: UInt16 {
    case readStatus = 0xF32D
    ...
}
```

Enumeration, usually called enum, is a group of related values. It starts with the keyword enum, followed by enumeration name. Inside the curly brackets, you put a series of cases. Each case could be attached to a value.
The enum Command contains the data for each command according to the datasheet for easier reference. 

```swift
func writeCommand(_ command: Command) {

}
```

Since the data of this sensor is represented in 16-bit, whereas I2C communication uses 8-bit data. This method is used to separate the 16-bit data into two 8-bit data by using a bitwise operation, then send the data via the I2C bus.

```swift
func startMeasure() -> (rawTemp: UInt16, rawHumi: UInt16) {

}
```

This method is about the measurement: 

1. Use the suitable command listed in the enum, send the data to the sensor using  writeCommand.
2. Then wait for a while to allow the sensor to sense the environment. 
3. Read data from the sensor. The sensor would send 6 bytes back to the board. 
4. The first two data are the values for temperature. The 4th and 5th are the values for humidity. Merge each two 8-bit values into 16-bit data. And return the raw temperature and humidity values.



:::note
Some bitwise operations are used in the data calculation: 

| Symbol | Meaning| Diagram |
|--------|---------|---------|
| << | left shift: all bits will move to the left, and 0 will be added to the empty bits on the right. |-|
| >> | right shift: all bits will move to the right, and 0 will be added to the empty bits on the left. |-|
| & | bitwise AND operator: it will calculate each corresponding bit of two data. Only if both two bits are 1, the result will be 1, or it will be 0. | - |
| \| | bitwise OR operator: it will calculate each corresponding bit of two data. If either of the bits is 1, the result will be 1. | - |


Take the operation in writeCommand for example:

```swift
UInt8(value >> 8)
```

The value is 16-bit. In the first operation, the bits will move to the right at first. So the original 8 bits on the right are discarded. In the new data, the 8 bits on the right are replaced by the original 8 bits on the left. The empty 8 bits on the left are completed with 0. After its type is changed to UInt8, leave the original 8 bits on the left.

```swift
UInt8(value & 0xFF)
```

The second does bitwise AND operation with 0xFF (1111 1111). So the right 8 bits would be the same as those of the original data. After it is changed to UInt8, leave the original 8 bits.
:::


If you do not quite understand the code above, don’t worry. This library is provided in the project and you just need to import it. Here, we just want you to get more familiar with I2C communication in actual projects. 
With the existing libraries, things are much easier. However, writing libraries is not an easy task - you need to consult the datasheet to transmit the data, to configure the device. So you may not do it at the very start. 


## Exercise
1. Read temperature and humidity

### 1. Read temperature and humidity

Let’s use the humiture to get the temperature and humidity. As you download the code, the sensor begins to work and you can see the value printed on the serial monitor. The value slightly changes. If you put your finger next to the sensor, the temperature will increase.

**Example code**

```swift
// Of course, you need to import the SwiftIO and SwiftIOFeather. Import the SHT3x to directly read values. 
import SwiftIO
import SwiftIOFeather
import SHT3x

// Initialize the I2C interface. And use it to initialize the sensor.
let i2c = I2C(Id.I2C0)
let sht = SHT3x(i2c)

// Read the temperature and humidity. Print their values out. Stop for 1s and repeat it.
while true {
    let temp = sht.readCelsius()
    let humidity = sht.readHumidity()
    print("Temperature: \(temp)C")
    print("Humidity: \(humidity)%")
    sleep(ms: 1000)
}
```



**Code analysis**

```swift
import SHT3x
```
MadDrivers contains several libraries about different devices and has been added to your project by default. SHT3x is one of them. So you just need to import it.

```swift
print("Temperature: \(temp)C")
print("Humidity: \(humidity)%")
```

Print the value out. 

The content is represented as a string, so you add double quotation marks. 

Besides, the value is a constant, so you will need string interpolation to combine them together. You will add its name as a placeholder after a backslash and between a pair of parentheses. And it will be replaced by its exact value.

## Summary

Glad you are here. In this project, you get to know a new communication protocol, then use it to talk to the humiture sensor. I wonder if you get the hang of it. When developing your project, you would not directly use the I2C, with the library, your code would like the second part above. 

## More info

* [I2C](https://www.analog.com/en/technical-articles/i2c-primer-what-is-i2c-part-1.html)
* [Number system conversion](https://code.tutsplus.com/articles/number-systems-an-introduction-to-binary-hexadecimal-and-more--active-10848)