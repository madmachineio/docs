---
title: Button-controlled LED
description: Learn how a button works and use it to control an LED.
---

# Button-controlled LED

The button is a commonly used input component and widely used in a light switch, remote control, keyboard, etc, to control the current flow in the circuit. Now itâ€™s your turn to build a LED light control using a button.  

**Learning goals**
* Know about digital input. 
* Understand how to use the button in your circuit. 
* Get to know why a pull resistor is necessary.
* Get a rough idea of interrupt and debounce. 

## ðŸ”¸Background

### What is digital input?
The microcontroller could not only send output voltage but also receive signals. You learned about digital output in the previous tutorial, and now you will discover how digital input works.

Like digital output, digital input has two states: high and low. When an input signal comes in, its voltage will be compared with specific thresholds. If the voltage higher than the threshold, itâ€™s high, and if itâ€™s lower, itâ€™s low. You can regard it as a multimeter used to measure voltage, but only has two results.

According to the input value, you could easily know the exact state of the external devices, for example, check if the button is pressed or not.

The digital pins on the board act as both input and output, so you need to initialize the pin as input in your code.


## ðŸ”¸New component

### Pushbutton 
Pushbutton is known as a momentary switch. In the simplified circuit below, by default, the circuit inside the button is disconnected, therefore block the current flow. As you press it, the internal metals comes into contact, so the current can flow successfully through the circuit. Once you release it, the button will go back to its original state and the current is blocked again. 

<img
  src={require('./img/button.png').default}
  alt="Button" width="960"
/>

Symbol: <img
  src={require('./img/buttonSymbol.png').default}
  alt="Button symbol" width="80" align="center"
/>


:::info
How to connect the button in the circuit?

This kind of button usually has four legs. Each two of them are shorted, like 1 and 3, 2 and 4 in the following diagram. If you connect the two legs that are shorted internally, like 1 and 3, the button is of no use since the current flows all the time. 

To make things easier, it is a good idea to connect the two legs on a diagonal, like 1 and 4, 2 and 3.
:::



### Pull resistor
As you have known, the input will always be either high or low. But if the input pin is connected to nothing, what will the input value be? High or low?

This is hard to say. The state of that pin will be uncertain and change randomly between high and low states. This state is called **floating**. To ensure a stable state, a pull-up or pull-down resistor is needed.

**Pull-up resistor**

The **pull-up resistor** connects the input pin to power. In this case, the button should connect to the input pin and ground. 

By default, when the button is not pressed, the input pin reads actually the power voltage which is high. If the button is pressed, the current flows from power directly to the ground and the pin reads low level.
       
**Pull-down resistor**

The **pull-down resistor** connects the input pin to ground. If so, the button should connect to the power and input pin. 

By default, the pin connects directly to the ground, so the pin keeps in a low state. And if you press the button, the current flows from power to the input pin, and the pin reads power voltage which is high.

<img
  src={require('./img/pullResistor.png').default}
  alt="Pull up and pull down resistor" width="960"
/>

In this way, the input pin is always at a determined state.

You would usually need them with a button. On this board, there are already internal pull-up and pull-down resistors. By default, the pull-down resistor is chosen. You could change it according to actual usage.

## ðŸ”¸Circuit
There are two buttons on your kit. They are connected respectively to **D1** and **D21**. 

<img
  src={require('./img/buttonCircuit.png').default}
  alt="Button module on the kit" width="960"
/>

<img
  src={require('./img/buttonCircuitDiagram.png').default}
  alt="Button circuit diagram" width="360"
/>


:::note
The circuits above are simplified for your reference.
:::

## ðŸ”¸Preparation
Letâ€™s see the new class you are going to use in this project.

**Class**

**`DigitalIn`** - this class is used to get the current state of a specified input pin.

| Method | Explanation |
| ------ | ----------- |
| `init(_:mode:)` | Initialize the digital input pin. <br />**`id`**: the id of the digital pin. <br />**`mode`**: set the pull resistors, `pullDown` by default. |
| `read()` | Read from an input pin. <br />It has a return value - the voltage on the pin, represented as `true` or `false`. |
| `setInterrupt(_:`<br />`enable:callback:)` | It allows you to define the interrupt mechanism in your project. This method needs three parameters: <br />**`mode`**: set the edge to trigger the interrupt: `.rising`, `.falling`, `.bothEdges`. <br />**`enable`**: decide whether to begin the interrupt detection once you set it. By default, it is `true` (enabled). <br />**`callback`**: pass in a closure as the paramter. It needs no parameter and returns nothing: () -> void. |


## ðŸ”¸Projects
1. [Control LED using a button](./button.mdx#1-control-led-using-a-button)
2. [Blink LED using interrupt](./button.mdx#2-blink-led-using-interrupt)

### 1. Control LED using a button
Letâ€™s start to build a simple LED switch. When you press the button, the LED turns on. When you release the button, the LED turns off.

<img
  src={require('./img/buttonLED.png').default}
  alt="Control LED with button" width="960"
/>

**Example code**

```swift
// Import the SwiftIO library to control input and output the MadBoard to use the id of the pins.
import SwiftIO
import MadBoard

// Initialize the input pin for the button and output pin for the LED.
let led = DigitalOut(Id.D19)
let button = DigitalIn(Id.D1)

// Keep repeating the following steps.
while true {
    // Read the input pin to check the button state.
    let value = button.read()
    // If the value is true which means the button is pressed, turn on the LED. Otherwise, turn off the LED.
    if value == true {
        led.write(true)
    } else {
        led.write(false)
    }
}
```

**Code analysis**

```swift
let button = DigitalIn(Id.D1)
```

The button is an instance created for the `DigitalIn` class. Of course, the id of the pin is necessary. Itâ€™s the pin the button connects: D1.

And there is an optional parameter `mode` with a default value `pullDown`, which means a pull-down resistor connects to the pin. There are two more options: `pullUp` (pull-up resistor), `pullNone` (no pull resistors).

```swift
button.read() 
```

Use the instance method `read()` to get the state from the pin. The return value tells you if it is high or low voltage. The value `true` means the button is being pressed.

```swift
if value == true {
    led.write(true)
} else {
    led.write(false)
}
```

The microcontroller will judge the value read from the pin. When the value equals true, it means the button is pressed, so make the board output a high voltage to turn on the LED. 


:::info
You might notice two similar symbols are so confusing: **=** and **==**. 

Well, = is to assign value to a constant or variable, while == compares if values are equal. 
:::



### 2. Blink LED using interrupt

In the previous project, the microcontroller is doing nothing but checking the input value over and over again to wait button press. But what if you want to do something else in the loop? When should the microcontroller check the pin state? Itâ€™s hard to decide.

So there comes another important mechanism - interrupt for the digital input.

**Interrupt**

The interrupt allows the microcontroller to respond quickly to a specified event. How does it work?

* Normally the microcontroller executes its main program. 
* Once the interrupt occurs, it will suspend the normal execution and then start the task with higher priority, called interrupt handler or ISR (Interrupt Service Routine). 
* After finished ISR, the microcontroller goes back to where it stopped and continues the main program until another interrupt.

<img
  src={require('./img/interrupt.png').default}
  alt="Interrupt" width="480"
/>

:::important
There are two points about the ISR:
1. Generally, the ISR should be done as fast as possible, usually in nanoseconds. 
2. The functions don't need any parameters and return anything.

In short, it's better to change a value or toggle digital output for the ISR. And you should not add `print()` (take about several milliseconds). Or your program may go wrong.
:::


An interrupt may come from different sources. Now you are dealing with an interrupt triggered by the state change. There are three **conditions** in total:
* **Rising edge**: when the signal changes from low to high. 
* **Falling edge**: when the signal changes from high to low. 
* **Both** of them.

<img
  src={require('./img/edges.png').default}
  alt="Rising edge and falling edge" width="480"
/>

So when setting the interrupt,  you need to tell the microcontroller the specific condition to trigger it: rising edge, falling edge, or both edges. Then once the specified edge is detected, the interrupt begins.

You may wonder why to use the interrupt. Well, with interrupt mechanism, the microcontroller can 
* respond instantly to what it is supposed to do, which is vital for time-critical events. 
* perform other tasks while the interrupt hasn't been triggered, thus increasing the efficiency.


**Example code**

```swift
// Import the SwiftIO library to control input and output the MadBoard to use the id of the pins.
import SwiftIO
import MadBoard

// Initialize the input pin for the button and output pin for the LED.
let button = DigitalIn(Id.D1)
let led = DigitalOut(Id.D19)

// Set the interrupt to detect the rising edge. Once detected, the LED will change its state.
button.setInterrupt(.rising) {
    led.toggle()
}

// Keep sleeping if the interrupt hasn't been triggered.
while true {
    sleep(ms: 9999)
}
```

**Code analysis**

```swift
button.setInterrupt(.rising) {
    led.toggle()
}
```

The interrupt will be triggered when a rising edge is detected. The rising edge here corresponds to the moment the button is pressed.


The third parameter is about closure. To simply put, the closure 






`toggle()` could reverse the output no matter itâ€™s current state. After the digital output is initialized, the LED is off. When the interrupt happens, the LED turns on. And if the rising edge is detected again, the LED turns off. As a result, the LED will change state every time you press the button.

```swift
while true {
    sleep(ms: 9999)
}
```

It is to ensure the board keep sleeping while interrupt doesn't happen. The sleep time can be a random value. Without it, the board will run extremely quickly again and again but doing nothing.



## ðŸ”¸Go further 
Congratulations! Now letâ€™s dive deeper into something more complicated. Donâ€™t be upset if you are confused. This part talks about the signal noise produced by buttons. You could skip this part and go back later as you get more familiar with all knowledge.

### Debounce 
When you press or release a button, you might think the button would immediately come to a stable state, closed or open. However, there would be some unexpected situations sometimes. 

The button has metals inside it which will move as you press or release it. Due to this mechanical structure, there may be several bounces before the internal metals finally settle down. So once the button is pressed or released, it may change several times between two states: establish the connection and disconnect the circuit before coming to a stable state.


The signal would thus change several times during this short period. It is not visible to your eye. You could observe it by viewing the wave in the oscilloscope. But the microcontroller works much faster. It may read the values during this uncertain period and regard these noises as multiple presses.

<img
  src={require('./img/bounce.png').default}
  alt="Bounce" width="480"
/>

So you need debounce methods to avoid this situation. There are many solutions, including hardware debounce and software debounce.

**Hardware debounce**

It lies in eliminating the influence of bounce when designing the circuit. So does the button on this kit. 

<img
  src={require('./img/debounce.png').default}
  alt="Debounce" width="960"
/>

A capacitor (C1 shown in the image below) is added to smooth the voltage changes. After the button is pressed or released, the voltage will gradually change to another level rather than accidentally change several times between the two levels.

There are also many other ways, of course.

**Software debounce**

It focuses on making your board ignore the bounce to get the real state. Usually, the key point is to check many times or wait a few milliseconds to skip this unstable period. Usually, a fast press would at least last about 20ms. So after this period, the value read from the pin should be the one needed. You could have a look at [this reference code](../general/simpleio/debounce.mdx#example-code). 

:::note
Since the button on the kit uses a hardware debounce method, you will not meet this problem. But it is still an important phenomenon when you DIY some projects using buttons.
:::


## ðŸ”¸Summary
In this tutorial, you know about digital input and the input component: button. Then you use digital input and digital output together to realize an interactive project - the LED switch. They are not so difficult as you think, right? Besides, you learn some more concepts, like interrupt and debounce. They may seem not so easy at the beginning. You could check them later as you learn more.

## ðŸ”¸More info
Find out more details in the links below if you are interested:

* [Pull resistor](https://eepower.com/resistor-guide/resistor-applications/pull-up-resistor-pull-down-resistor/#)
* [Button bounce](https://circuitdigest.com/electronic-circuits/what-is-switch-bouncing-and-how-to-prevent-it-using-debounce-circuit)
