---
title: LCD display
description: Learn how to
---

# LCD display

Let's display something interesting on the LCD screen. 

Welcome to the most exciting part of this tutorial. LCD screens are a wonderful tool to show and display what you want: show text or data, draw simple shapes, display BMP images or create fancy interfaces, etc. 

**Learning goals**
* Get a general idea of SPI protocol
* Understand the coordinate system of  LCD
* Know how the color is represented on the screen
* Learn to draw simple graphics on LCD

## Background

### What is SPI?

Serial Peripheral Interface, SPI for short, is another synchronous communication protocol between devices. It supports only one master with one or multiple devices.

SPI needs normally four wires: 

* SCK: serial clock. This is the clock signal generated by the master, that’s to say, the SwiftIO feather. It could ensure synchronous data transmission between master and slave devices. And SPI transmission speed is much higher than I2C.
* SDI: serial data in. This data line is used for the master device to receive data from the slave.
* SDO: serial data out. This data line is used for the master device to send data to slaves.
* CS: chip select. This signal is generated by the master to select the slave device. If there are several slave devices, each one needs a select signal that connects to the master. So you could write or read data directly, and there is no need for an address

All in all, you could just regard it as a combination of input and output following some established transmission rules. During your usage, you just find the necessary data on the device datasheet and send them using the SPI bus.

## New component
### LCD
There are so many kinds of screens to display characters or graphics. The one you are going to use is a TFT LCD screen (Thin-film-transistor liquid crystal display). It could display all colors. And it provides a great view from all angles. 

This 1.54 inches LCD has a resolution of 240x240 pixels. And each pixel needs 16-bit color. One pixel is one point on the LCD.  When you display some stuff on it, what you do is actually set these pixels. 

The size and the resolution of the LCD will decide how the display looks. Bigger size with higher resolution will certainly provide a better view, but it will need more time for the processing and also more storage.  

For the screen, the coordinate system is quite different from what you get used to before. The origin (0,0) is located in the upper left corner. The values in the x-axis and y-axis gradually increase from 0 to maximum, and all the coordinates are between (0,0) and (239,239). 


If you want to display some graphics on the screen, you need to set the corresponding pixels. So you need the coordinates and the colors data. Then the screen interfaces with the board using SPI protocol to transmit the data. 

## New concept

### Color depth

Color depth, or bit depth, describes the number of bits to represent a pixel on the screen, i.e. the amount of colors that each pixel could display. For each bit, there are only two values: 0 or 1. So you could easily get the total number of colors: 2 to the power of the number of bits. The color depth you will always see is 16-bit, 24-bit, and 32 bit.

* For 16-bit color, also called high color, there are 65536 colors in total. It uses 5, 6, 5 bits to respectively represent red, green, and blue.
* 24-bit color depth is also called True Color. There are about 16 million colors. The bits are evenly divided to represent RGB colors: 8 for red, 8 for green, and 8 for blue. 
* 32-bit color, quite like 24-bit color, uses 8-bit for red, 8-bit for green, and 8-bit for blue. What’s more, there is an alpha channel to represent the degree of transparency.

The color code normally uses 8 bits to represent each color in hexadecimal. For example, FFFFFF represents white, 000000 represents black. 

However, the screen you’ll use in this kit supports 16-bit color. So if you are going to define the color used on this screen, you need to convert 24-bit color to 16-bit color. Usually, you will take the bits of each color from the most significant bit, because they have more impact on the color. There are some online converters you can use to directly get 16-bit value. 

### Image format

When you scale up images several times, you may notice some of the images are just the same and don't lose any quality, this kind of image is called a vector image. It uses points and lines to create paths and is based on mathematical formulas. The font used on the website is usually vector format. It will never be blurry as you zoom it in.

While for other images, multiple grids begin to appear as it is zoomed in to a certain degree, this kind of image is called a raster image, also known as bitmap. Each grid is the smallest unit, and is one pixel. Each pixel contains bits of color. And the combination of all the pixels forms the final image. More pixels will form an image with higher quality. 

There are two commonly used file formats of bitmap. BMP stands for bitmap. The bmp image is an uncompressed file and stores the color data for all pixels, hence it is large in size. JPG file uses compression algorithms to deal with similar pixels to reduce the file size. So it needs to be decoded as you open the file. 

## Circuit
The LCD is connected to SPI0 for communication. The other wires connected to the digital pins are used to configure the LCD.



:::note
The circuits above are simplified for your reference.
:::

## Preparation

Let’s first get to know the method you will use to display something on the screen.
Class
SPI: send and receive data using SPI protocol.
Method
init(_:speed:csPin)
Initialize the SPI interface. 
The first parameter is the pin name. 
Then it’s the communication speed. 
The third one defines a DigitalOut pin as a CS pin. It is nil by default. If you don’t set it, you need to control it manually through any DigitalOut pin.


Class
ST7789: it configures the LCD and allows you to draw pixels on it.

Method
init()
Initialize the LCD. You need to tell the SPI interface and some digital pins used to configure it.
writePixel(x:y:color:)
This is used to write a single pixel on the screen. 
First, you will define the coordinate of the pixel. Then it’s the UInt16 color value.
writeBitmap(x:y:width:height: data:)
It allows you to draw a rectangle on the screen.
It needs the coordinate of the starting point, that is, the left upper corner of the rectangle. 
Define the width and height of the rectangle. 
Finally comes the color data stored in an array. And please note the data is stored in UInt8, so two values are used for one pixel.
clearScreen(_:)
It allows you to paint the whole screen with one color. It needs the color data in UInt16. 


These methods to draw on the screen are actually quite similar. 

The method writePixel has a default value of 1 for both width and height. It draws a single pixel, so it needs only one color data. It is the most basic operation. If you want to display whatever graphic, like circle, rectangle, triangle, etc, it is just about the calculation of the coordinates to decide which pixels are going to show which color.

The method writeBitmap fills a block of pixels on the screen, so you need to tell the position of the pixels which is decided by the starting point, width, and height, as well as the colors of all pixels. 
The method clearScreen(_:) has the default info of the pixels and just needs the color value.

## Exercise
1. LCD display

### 1. LCD display
You are going to use the library ST7789 to paint the screen and draw some simple stuff on it.


**Example code**

```swift
// Import the two basic libraries.
import SwiftIO
import SwiftIOFeather
// Import the library to configure the LCD and write pixels on it.
import ST7789

// Initialize the SPI pin and the digital pins.
let spi = SPI(Id.SPI0, speed: 50_000_000)
let cs = DigitalOut(Id.D9)
let dc = DigitalOut(Id.D10)
let rst = DigitalOut(Id.D14)
let bl = DigitalOut(Id.D2)

// Initialize the LCD using the pins above. Rotate the screen to keep the original at the upper left.
let screen = ST7789(spi: spi, cs: cs, dc: dc, rst: rst, bl: bl, rotation: .angle90)

// Store some color values for easier use later.
let black: UInt16 = 0x0000
let red: UInt16 = 0xF800
let green: UInt16 = 0x07E0
let blue: UInt16 = 0x001F
let white: UInt16 = 0xFFFF

// Set all pixels to red, then green, blue, white, and black respectively. Every second it changes to another color. 

screen.clearScreen(red)
sleep(ms: 1000)

screen.clearScreen(green)
sleep(ms: 1000)

screen.clearScreen(blue)
sleep(ms: 1000)

screen.clearScreen(white)
sleep(ms: 1000)

screen.clearScreen(black)
sleep(ms: 1000)

// Draw red horizontal lines every 10 rows, so the lines will be on rows 0, 10, 20, ..., 230.
for y in stride(from: 0, to: screen.height, by: 10) {
    for x in 0..<screen.width {
        screen.writePixel(x: x, y: y, color: red)
    }
}
sleep(ms: 1000)

// Draw blue vertical lines every 10 columns, so the lines will be on columns 0, 10, 20, ..., 230.
for x in stride(from: 0, to: screen.width, by: 10) {
    for y in 0..<screen.height {
        screen.writePixel(x: x, y: y, color: blue)
    }
}
sleep(ms: 1000)

// Paint the screen black to erase all stuff on it.
screen.clearScreen(black)
sleep(ms: 1000)

// Store the colors of four squares that will be used later.
let colors = [red, green, blue, white]

// Set the size of the square.
let width = 80

// First, draw a 80x80 red square from the origin. 
// After one second, draw a green one from the centre of the red square.
// The blue and white ones are similar.
while true {
    var x = 0, y = 0

    for color in colors {
        fillSquare(x: x, y: y, width: width, color: color)
        x += width / 2
        y += width / 2
        sleep(ms: 1000)
    }
}

// This function allows you to draw a square on the LCD. It starts from the point (x,y). It actually uses two loops to set every pixel.
func fillSquare(x: Int, y: Int, width: Int, color: UInt16) {
    for px in y..<(y + width) {
        for py in x..<(x + width) {
            screen.writePixel(x: px, y: py, color: color)
        }
    }
}
```




**Code analysis**
```swift
let screen = ST7789(spi: spi, cs: cs, dc: dc, rst: rst, bl: bl, rotation: .angle90)
```
You need to initialize the LCD before using it.
* It needs several pins: a SPI interface of course, as well as 4 digital pins for LCD configuration that were initialized before.
* Then it’s the size of the screen. Since the chip ST7789 supports screens of different sizes. The default size is 240x240 and it is what you are using. So you don’t need to specify it here.

* At last, it’s the rotation of the screen. The screen rotates by 90 degrees when designing the circuit, so if you don’t set the rotation, the origin will be at the lower left corner. To have a better view, you could set the rotation to .angle90 to put the origin at the upper left corner.

```swift
for y in stride(from: 0, to: screen.height, by: 10) {
    for x in 0..<screen.width {
        ...
    }
}
```

As you use the function stride(from:to:by:), the y will start from 0, increased by 10 each time, until it’s close to the height of the screen, since it is not included in the range. And the value of x will be from 0 to 239.

## Summary
Congratulations! You know the coordinate system on the screen, as well as the different ways the colors are represented. Then you draw some graphics on the screen using different colors. There is a lot to do with the LCD. You will dive deeper into it in chapter3.

## More info
* [SPI](https://www.analog.com/en/analog-dialogue/articles/introduction-to-spi-interface.html)
* [24-bit to 16-bit converter](http://www.barth-dev.de/online/rgb565-color-picker/) 