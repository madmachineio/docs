---
title: LCD display
description: Learn how to
---

# LCD display
 

Welcome to the most exciting part of this kit. LCDs are wonderful tools to display: text or data, simple shapes, BMP images or fancy interfaces, etc. Let's start!

**Learning goals**
* Get a general idea of SPI protocol.
* Understand the coordinate system of  LCD.
* Know RGB color model.
* Learn to draw simple graphics on LCD.

## ðŸ”¸Background

### What is SPI?

**Serial Peripheral Interface**, SPI for short, is another synchronous communication protocol between devices. It supports only one master with multiple devices, but its speed is much faster than the I2C.

SPI ususally needs four wires: 

* **SCK** (serial clock): it carries the clock signal generated by the master (the SwiftIO feather), which is used to ensure synchronous data transmission. 
* **SDI** (serial data in): also called MISO. The master device receives data from slave devices through this wire.
* **SDO** (serial data out): also called MOSI. The master device sends data to slave devices through this wire.
* **CS** (chip select): master device generates this signal to select the specified slave device. Each slave device needs a CS that connects to the master. At the beginning of an SPI communication, the master device will set the CS line to wake up the corresponding device and keep others unchanged. In this way, there is no need for an address like I2C.

<img
  src={require('./img/SPI.png').default}
  alt="SPI" width="480"
/>

SPI has 4 modes: 0, 1, 2, 3, which is decided by CPOL and CPHA. 
* **CPOL** (clock polarity): it depends on the state of SCK when the line is idle. 1 for high and 0 for low.
* **CPHA** (clock phase): it descibes the sampling phase relative to the clock signal. If the data is sampled at the first edge of clock pulse, it is 0. If it's sampled at second edge, it's 1.

<img
  src={require('./img/spiMode.png').default}
  alt="SPI mode" width="480"
/>


As for data transmission, there are two modes which tells how data is sent: most-significant bit (MSB) first, or least-significant bit (LSB) first. In a byte, MSB is the left-most bit and LSB is the right-most bit.

All in all, you could regard SPI communication as a combination of input and output following some established transmission rules. Its main work is to read (receive) and write (send) data, and all other details such as mode define how the data is sent and interpreted.

## ðŸ”¸New component
### LCD
There are so many kinds of screens to display characters or graphics. The one you are going to use is a TFT LCD screen (Thin-film-transistor liquid crystal display). It provides a great view from all angles. 

This 1.54 inches LCD on your kit has 240x240 pixels. One pixel means one point on the LCD. To display some stuff on the LCD, you need to set the pixels. Each pixel needs a 16-bit color. 

The coordinate system on screens is quite different from what you get used to before. The origin (0,0) is in the upper left corner. The values in the x-axis and y-axis gradually increase from 0 to maximum. So all the coordinates for this LCD are from (0,0) to (239,239). 

<img
  src={require('./img/lcd.png').default}
  alt="LCD" width="480"
/>

If you want to display some graphics on a screen, you need to set the corresponding pixels. So you tell the coordinates and the colors data. All data is sent to the LCD via SPI wires. 

## ðŸ”¸New concept

### RGB color model

RGB color model is a common way to describe colors in many displays, for example, on your computer monitor. RGB represents red, green, and blue. They are the basis of colors. The combination of three colors with different intensities forms a broad range of colors: red and green form yellow, green and blue form cyan, blue and red form magenta, the combination of rgb colors form white. 

<img
  src={require('./img/rgb.png').default}
  alt="RGB color model" width="240"
/>


### Color depth

**Color depth**, or bit depth, describes the number of bits to represent a pixel on the screen, in other words, the count of colors that each pixel can display. For each bit, there are two values: 0 or 1. So you could easily get the total number of colors: 2 to the power of the number of bits. The color depth you will always see is 16-bit, 24-bit, and 32 bit.

* For 16-bit color, also called high color, there are 65536 colors in total. The values are divided into 5, 6, 5 bits, representing red, green, and blue.
* 24-bit color depth is called True Color. There are about 16 million colors. The bits are evenly divided to represent RGB colors: 8 for red, 8 for green, and 8 for blue. 
* 32-bit color, quite like 24-bit color, uses 8-bit for red, 8-bit for green, and 8-bit for blue. Besides, there is an 8-bit alpha channel to represent the degree of transparency.

The color code normally uses 8 bits to represent each color in hexadecimal. For example, 0xFFFFFF represents white, 0x000000 represents black, 0xFF0000 represents red.

<img
  src={require('./img/rgb888.png').default}
  alt="24-bit RGB color" width="480"
/>

However, the LCD module in this kit supports 16-bit color. So if you are going to define the color for this screen, you need to convert 24-bit color to 16-bit color. Usually, you will take the bits of each color from the most significant bits as below, because they have more effect on the color. You can use the [online converters](http://www.barth-dev.de/online/rgb565-color-picker/) to get 16-bit color values from 24-bit. 

<img
  src={require('./img/rgb565.png').default}
  alt="16-bit RGB color" width="480"
/>

### Image format

When you scale up images several times, you may notice some of the images are just the same and don't lose any quality. These images are called **vector** images. They use points and lines to create paths based on mathematical formulas. The fonts used on all websites are usually vector format. It will never be blurry as you zoom it in.

While for other images, multiple grids begin to appear as they are zoomed in to a certain degree. These images are called **raster** images, also known as bitmaps. Each grid on it is the smallest unit, called one pixel. The combination of all pixels forms the final image. More pixels will form an image with higher quality. 

<img
  src={require('./img/rasterVector.png').default}
  alt="Raster and vector image" width="320"
/>

There are two commonly used file formats of bitmap. 
* **BMP** stands for bitmap. The bmp image is an uncompressed file and stores the color data for all pixels, hence it is large in size. 
* **JPG** file uses compression algorithms to deal with similar pixels to reduce the file size. So it needs to be decoded as you open the file. 

## ðŸ”¸Circuit - LCD module

The LCD is connected to **SPI0** for communication, D9 for CS signal. The other wires connected to the digital pins are used to configure the LCD.

<img
  src={require('./img/lcdCircuit.png').default}
  alt="LCD circuit.png" width="960"
/>

<img
  src={require('./img/lcdCircuitDiagram.png').default}
  alt="LCD circuit diagram.png" width="360"
/>

:::note
The circuits above are simplified versions for your reference.
:::

## ðŸ”¸Preparation

**Class**

**`SPI`** - this class is used to send and receive data using SPI protocol.

| Method | Explanation |
| ------ | ----------- |
| `init(_:speed:csPin:`<br />`CPOL:CPHA:bitOrder:)` | Initialize an SPI interface. <br />**Parameter:** <br /> - `idName`: spi pin id that the LCD connects to. <br /> - `speed`: the communication speed, 5MHz by default. <br /> - `csPin`: a `DigitalOut` pin as a CS pin. It is nil by default. If you donâ€™t set it, you need to control it manually. <br />- `CPOL`: the state of clock signal when it's idle, `false` by default. <br />- `CPHA`: the edge of clock signal to sample data, `false` by default. <br />- `bitOrder`: the bit order during data transmission, `.MSB` by default. |


**`ST7789`** - it configures the LCD and allows you to draw pixels on it.

| Method | Explanation |
| ------ | ----------- |
| `init(spi:cs:dc:rst:bl:`<br />`width:height:rotation:)` | Initialize the LCD. <br />**Parameter:** <br /> - `spi`: the SPI interface that the LCD connects to.<br />- `cs`: the cs pin for SPI communication. The cs pin is controlled in this class, so the `csPin` in `SPI` class should be nil. <br />- `dc`: a `DigitalOut` pin used for data and command selection. <br />- `rst`: a `DigitalOut` pin used to reset the LCD.<br />- `bl`: a `DigitalOut` pin used for backlight control.<br /> - `width`: the width of the LCD, 240 by default.<br /> - `height`: the height of the LCD, 240 by default. <br />- `rotation`: the degree of LCD rotation, `.angle0` by default. It is used to set the position of origin. |
| `writePixel(x:y:color:)` | Set a single pixel on the screen. <br />**Parameter:**<br /> - `x`, `y`: the coordinate of the pixel. <br /> - `color`: a UInt16 color value. |
| `writeBitmap(x:y:`<br />`width:height: data:)` | Set an area of pixels on the screen. <br />**Parameter:**<br />- `x`, `y`: the coordinate of the starting point, that is, the left upper corner of the rectangle. <br /> - `width`: the width of the area.<br /> - `height`: the height of the area. <br /> - `data`: the color data stored in an UInt8 array. Please note the data is stored in UInt8, so two values are used for one pixel. |
| `clearScreen(_:)` | Fill the whole screen with one color. <br />**Parameter:**<br /> - `color`: a color data in UInt16. |


These methods to draw on the screen are quite similar:

* The method **`writeBitmap`** fills a block of pixels on the screen. You need to tell the position of the pixels which is decided by the starting point, width, and height. The pixels of the LCD need 16-bit colors, the color values stored in the array is 8-bit, so the count of the color array equals width x height x 2. 

  For example, the color of the rectangle below is represented as 0xF483. So the `color` passed in should be `[0xF4, 0x83, 0xF4, 0x83, 0xF4, 0x83, 0xF4, 0x83, 0xF4, 0x83, 0xF4, 0x83]`.

  <img
    src={require('./img/writeBitmap.png').default}
    alt="Write a bitmap on screen" width="240"
  />

* The method **`writePixel`** has a default value of 1 for both width and height to draw a single pixel, so it needs only one color data. It is the most basic operation. If you want to display whatever graphic, like a circle, rectangle, triangle, etc, it is just about the calculation of the coordinates to decide which pixels need to be set.
* The method **`clearScreen`** sets the bitmap to screen size, so it just needs a color value.

## ðŸ”¸Projects
1. [LCD display](./lcd#1-lcd-display)

### 1. LCD display
You are going to use the library `ST7789` to paint the screen and show some simple animation on it.


**Example code**

```swift
// Import SwiftIO to set the communication and MadBoard to use pin id. 
import SwiftIO
import MadBoard
// Import the library to configure the LCD and write pixels on it.
import ST7789

// Initialize the SPI pin and the digital pins for the LCD.
let spi = SPI(Id.SPI0, speed: 50_000_000)
let cs = DigitalOut(Id.D9)
let dc = DigitalOut(Id.D10)
let rst = DigitalOut(Id.D14)
let bl = DigitalOut(Id.D2)

// Initialize the LCD using the pins above. Rotate the screen to keep the original at the upper left.
let screen = ST7789(spi: spi, cs: cs, dc: dc, rst: rst, bl: bl, rotation: .angle90)

// Store some color values for easier reference later.
let black: UInt16 = 0x0000
let red: UInt16 = 0xF800
let green: UInt16 = 0x07E0
let blue: UInt16 = 0x001F
let white: UInt16 = 0xFFFF

// Fill the whole screen with red, green, blue, white, and black in turns. 
// The color changes every second. 
screen.clearScreen(red)
sleep(ms: 1000)

screen.clearScreen(green)
sleep(ms: 1000)

screen.clearScreen(blue)
sleep(ms: 1000)

screen.clearScreen(white)
sleep(ms: 1000)

screen.clearScreen(black)
sleep(ms: 1000)

// Draw red horizontal lines every 10 rows, so the lines will be on rows 0, 10, 20, ..., 230.
for y in stride(from: 0, to: screen.height, by: 10) {
    for x in 0..<screen.width {
        screen.writePixel(x: x, y: y, color: red)
    }
}
sleep(ms: 1000)

// Draw blue vertical lines every 10 columns, so the lines will be on columns 0, 10, 20, ..., 230.
for x in stride(from: 0, to: screen.width, by: 10) {
    for y in 0..<screen.height {
        screen.writePixel(x: x, y: y, color: blue)
    }
}
sleep(ms: 1000)

// Paint the screen black to erase all stuff on it.
screen.clearScreen(black)
sleep(ms: 1000)

// Store the colors of four squares for later use.
let colors = [red, green, blue, white]

// Set the size of the square.
let width = 80

// First, draw a 80x80 red square from the origin. 
// After one second, draw a green one from the centre of the red square.
// The blue and white ones are similar.
while true {
    var x = 0, y = 0

    for color in colors {
        fillSquare(x: x, y: y, width: width, color: color)
        x += width / 2
        y += width / 2
        sleep(ms: 1000)
    }
}

// This function allows you to draw a square on the LCD from the point (x,y).
func fillSquare(x: Int, y: Int, width: Int, color: UInt16) {
    for px in y..<(y + width) {
        for py in x..<(x + width) {
            screen.writePixel(x: px, y: py, color: color)
        }
    }
}
```




**Code analysis**
```swift
let screen = ST7789(spi: spi, cs: cs, dc: dc, rst: rst, bl: bl, rotation: .angle90)
```
You need to initialize the LCD before using it.
* The LCD needs several pins: an SPI interface, of course, and 4 digital pins for LCD configuration. The cs pin should be set either when initializing an SPI pin or when initializing the device. Here, it's set when initializing the LCD as the driver has configured the pin during communication.
* Then itâ€™s the size of the screen. Since the chip ST7789 supports screens of different sizes. The default size is 240x240 and it is what you are using. So you donâ€™t need to specify it here.

* At last, itâ€™s the rotation of the screen. The screen rotates by 90 degrees when designing the circuit, so if you donâ€™t set the rotation, the origin will be at the lower left corner. To have a better view, you could set the rotation to .angle90 to put the origin at the upper left corner.

<img
  src={require('./img/LCDRotation.png').default}
  alt="LCD Rotation" width="960"
/>

```swift
for y in stride(from: 0, to: screen.height, by: 10) {
    for x in 0..<screen.width {
        ...
    }
}
```

As you use the function stride(from:to:by:), the y will start from 0, increased by 10 each time, until itâ€™s close to the height of the screen, since it is not included in the range. And the value of x will be from 0 to 239.


## ðŸ”¸More info
* [SPI](https://www.analog.com/en/analog-dialogue/articles/introduction-to-spi-interface.html)
* [24-bit to 16-bit converter](http://www.barth-dev.de/online/rgb565-color-picker/) 