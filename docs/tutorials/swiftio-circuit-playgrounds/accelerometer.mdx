---
title: Movement sensing using accelerometer
description: Learn how to 
---

# Movement sensing using accelerometer 

Letâ€™s measure the movement of the object.

You may not have heard of accelerometers, but you must experience them in everyday life. For example, when you rotate your mobile phone, you may find the screen display rotate portrait to landscape. Actually, it's due to the accelerometer inside the phone. It senses the movement and then responds to it accordingly. Now letâ€™s take a closer look at it.

**Learning goals**

* Understand how an accelerometer senses movements.
* Know about acceleration. 

## ðŸ”¸New component

### Accelerometer

The accelerometer, aka 3-axis accelerometer, is useful to measure motion and gives the accelerations on x, y, z-axis. You could infer the movement according to the values. 

<img
  src={require('./img/accelerometer.png').default}
  alt="Accelerometer" width="320"
/>

The accelerometer can sense gravity and measure motion, like vibration, rotation. The sensor contains a structure whose part moves when an acceleration is applied. The internal capacitance of the sensor changes with it, and thus voltage in circuits also changes.

<img
  src={require('./img/mems.png').default}
  alt="mems" width="960"
/>

To better understand how the accelerometer works, letâ€™s imagine a small ball inside a vacuum box. There are several situations: 

* There is no gravity in a vacuum box, so the ball floats in the middle. 
* If you suddenly move the box to the left, the ball will move towards the opposite direction and hit the box. This is similar to the experience when you take a bus. If the bus suddenly speeds up, your body feels a force backward and then moves backward. This force is known as inertial force. 
* If air comes into the box, the ball will fall due to gravity. 

<img
  src={require('./img/ballinbox.png').default}
  alt="A ball in box to show the acceleration" width="960"
/>
              
Now letâ€™s go back to the sensor.

* If the sensor is still, it only feels the gravity. When the sensor faces up on the table, it gets a force downwards on the z-axis. When the sensor is perpendicular to the table, there will be a force on the x or y-axis.

<img
  src={require('./img/accelerometerDirection.png').default}
  alt="Accelerometer in three directions" width="960"
/>

* If the sensor moves toward some directions, the sensor should sense corresponding inertial force and gravity force.



The acceleration describes the change of velocity with time, in meters per second squared (m/s2). It has directions and can be either positive or negative. The gravitational acceleration on earth equals 1g (9.8m/s2). The accelerations measured by the sensor are in g.

The accelerometer you are going to use supports I2C communication. The data it sends on the bus is raw values ranging from -32768 to 32767 (16-bit). Then the values will be converted to the acceleration value proportionally according to the measurement range. 

The sensor provides several measurement ranges: Â±2g, Â±4g, Â±8g, Â±16g. If you choose Â±2g, -32768 equals -2g and 32768 equals 2g, which gives more precise readings within the limited range.

## ðŸ”¸Circuit - accelerometer module
The accelerometer module is connected to **I2C0**.

<img
  src={require('./img/accelerometerCircuit.png').default}
  alt="Accelerometer circuit" width="960"
/>

<img
  src={require('./img/accelerometerCircuitDiagram.png').default}
  alt="Accelerometer circuit diagram" width="360"
/>

:::note
The circuits above are simplified versions for your reference.
:::

## ðŸ”¸Preparation

**Class**

**`LIS3DH`** - it provides predefined methods for you to get readings from the accelerometer in an easy way.

| Method | Explanation |
| ------ | ----------- |
| `init()` | Initialize the sensor to start the communication. It needs an I2C interface. The address has a default value. |
| `readXYZ()` | Read the acceleration on 3-axis. It will return three values in float. |

## ðŸ”¸Exercise
1. [Read acceleration](./accelerometer#1-read-acceleration)
2. [Tilt indicator](./accelerometer#2-tilt-indicator)

### 1. Read acceleration
Letâ€™s use the sensor to sense movements. As you move or tilt your board in different directions, the values printed on the window change accordingly.

**Example code**

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs
  defaultValue="main"
  values={[
    { label: 'main.swift', value: 'main', },
    { label: 'Package.swift', value: 'package', },
  ]
}>

<TabItem value="main">

```swift
// Import SwiftIO to set the communication and MadBoard to use pin id. 
import SwiftIO
import MadBoard
// Import LIS3DH to read the accelerations from the sensor.
import LIS3DH

// Initialize the I2C pins and the sensor.
let i2c = I2C(Id.I2C0)
let acc = LIS3DH(i2c)

// Read the accelerations and each of them.
while true {
    let value = acc.readXYZ()
    print("x: \(value.x)g")
    print("y: \(value.y)g")
    print("z: \(value.z)g")
    print("\n")
    sleep(ms: 1000)
}
```
</TabItem>
<TabItem value="package">

```swift"
import PackageDescription

let package = Package(
    name: "Humiture",
    dependencies: [
        // Dependencies declare other packages that this package depends on.
        .package(url: "https://github.com/madmachineio/SwiftIO.git", .branch("main")),
        .package(url: "https://github.com/madmachineio/MadBoards.git", .branch("main")),
        // highlight-next-line
        .package(url: "https://github.com/madmachineio/MadDrivers.git", .branch("main")),
    ],
    targets: [
        // Targets are the basic building blocks of a package. A target can define a module or a test suite.
        // Targets can depend on other targets in this package, and on products in packages this package depends on.
        .target(
            name: "Humiture",
            dependencies: [
                "SwiftIO",
                "MadBoards",
                // highlight-next-line
                .product(name: "LIS3DH", package: "MadDrivers")
            ]),
        .testTarget(
            name: "HumitureTests",
            dependencies: ["Humiture"]),
    ]
)
```
</TabItem>
</Tabs>


### 2. Digital dice

Let's build a dice with the accelerometer. You can shake or tilt the sensor to change the accelerations. It simulates the process of rolling a dice. After that, you put it back on your table or keep it in horizontal position, you should get a random number from 1 to 6.


**Example code**

<Tabs
  defaultValue="main"
  values={[
    { label: 'main.swift', value: 'main', },
    { label: 'Package.swift', value: 'package', },
  ]
}>

<TabItem value="main">

```swift
// Import SwiftIO to set input and output.
import SwiftIO
// Import MadBoard to use the id of the pins.
import MadBoard
// Import this driver to read accelerations on x, y, z-axis.
import LIS3DH

// Initialize an I2C interface and use it to set the sensor.
let i2c = I2C(Id.I2C0)
let dice = LIS3DH(i2c)

// Initialize an LED used as an indicator when shaking the sensor.
let indicator = DigitalOut(Id.D19)

// Create a variable to store the time period when the sensor settle down.
var steadyCount = 999

while true {
    let diceValue = dice.readXYZ()
    

    if abs(diceValue.x) > 0.3 || abs(diceValue.y) > 0.3 {
        indicator.high()
        steadyCount = 0
    } else {
        steadyCount += 1
        if steadyCount == 50 {
            indicator.low()
            print(Int.random(in: 1...6))
        }
    }

    sleep(ms: 5)
}

```
</TabItem>
<TabItem value="package">

```swift"
import PackageDescription

let package = Package(
    name: "Humiture",
    dependencies: [
        // Dependencies declare other packages that this package depends on.
        .package(url: "https://github.com/madmachineio/SwiftIO.git", .branch("main")),
        .package(url: "https://github.com/madmachineio/MadBoards.git", .branch("main")),
        // highlight-next-line
        .package(url: "https://github.com/madmachineio/MadDrivers.git", .branch("main")),
    ],
    targets: [
        // Targets are the basic building blocks of a package. A target can define a module or a test suite.
        // Targets can depend on other targets in this package, and on products in packages this package depends on.
        .target(
            name: "Humiture",
            dependencies: [
                "SwiftIO",
                "MadBoards",
                // highlight-next-line
                .product(name: "LIS3DH", package: "MadDrivers")
            ]),
        .testTarget(
            name: "HumitureTests",
            dependencies: ["Humiture"]),
    ]
)
```
</TabItem>
</Tabs>


**Code analysis**

```swift
let indicator = DigitalOut(Id.D19)
```

This LED is served as an indicator when shaking the sensor. Or you may not sure what happens.

```swift
var steadyCount = 999
```

This statement declares a new variable used to store the time. While you shake the sensor, the accelerations change in undetermined states. This count can infer if the sensor comes to a horizontal position after a shake.

```swift
if abs(diceValue.x) > 0.3 || abs(diceValue.y) > 0.3 {
    indicator.high()
    steadyCount = 0
} else {
    steadyCount += 1
    if steadyCount == 50 {
        indicator.low()
        print(Int.random(in: 1...6))
    }
}
```
An if-else statement is used to judge the sensor's state.

* The accelerations should increase in magnitude when you shake the sensor. Since the accelerations have directions, you need to use `abs` to get absolute values. During that time, you turn on the LED as an indicator. The variable `steadyCount` is set to 0 and always be 0 when the sensor is still in motion.

* Once you stop shaking the sensor, the accelerations on the x and y-axis decrease and should be lower than the threshold. Then the count starts to increase until it exceeds the set value. If so, it means the sensor is kept in a horizontal position. This is similar to the period after a dice is thrown. At last, you should see a number printed on your serial window.

In this exercise, the key point is to decide when the sensor is no longer in motion. Here you will store the time to make sure the state lasts for a certain period. 


