---
title: About MadDisplay
description: Learn how to
---

# About MadDisplay


If you have dealt with Adobe photoshop or illustrator, you must be familiar with the operations based on different layers. And that’s the point of this library. You can create and group different elements as you like to form a wonderful display.
 
## Introduction

There are four core concepts for this library:

* **Bitmap**: it stores an indexed color of each pixel. The actual color values are in a Palette.
* **Palette**: it stores all colors that the bitmap needs in order.
* **Tile**: it will combine the bitmap and palette to get a colored image.
* **Group**: a group can contain one or several tiles, or even groups. It is what you will display on the screen. 

The image below shows how it works: 

1. You first get a bitmap where all pixels are filled with indexed colors. 
2. You create a palette with actual colors. Each color has an index that matches with those on the bitmap.
3. You combine the bitmap and palette together to get a tile. All the pixels are filled with RGB colors.
4. After creating one or several tiles, you could add them to a group and display that group on the screen.

<img
  src={require('./img/layers.png').default}
  alt="Layers" width="960"
/>

In this way, you could well organize the elements for the display and easily change or move any of the elements without messing up the whole display.

Let’s begin with a simple display. Here is a sample code to use the 4 concepts in the display:

```swift
import SwiftIO
import MadBoard
import ST7789
import MadDisplay

let spi = SPI(Id.SPI0, speed: 30_000_000)
let cs = DigitalOut(Id.D9)
let dc = DigitalOut(Id.D10)
let rst = DigitalOut(Id.D14)
let bl = DigitalOut(Id.D2)

let screen = ST7789(spi: spi, cs: cs, dc: dc, rst: rst, bl: bl, rotation: .angle90)

let display = MadDisplay(screen: screen)

let palette = Palette()
palette.append(Color.white)
palette.append(Color.black)
palette.append(Color.red)
palette.append(Color.yellow)

let bitmap = Bitmap(width: 200, height: 200, bitCount: 2)

for x in 50...150 {
    for y in 50...150 {
        bitmap.setPixel(x:x, y:y, 3)
    }
}

let tile = Tile(x: 20, y: 20, bitmap: bitmap, palette: palette)

let group = Group()
group.append(tile)

display.update(group)

while true {
    sleep(ms: 1000)
}
```

After you download the code, you will see the screen as below:

<img
  src={require('./img/display.png').default}
  alt="Display on the screen" width="240"
/>

Now, let’s look at each part in detail to understand how it works.

###  Palette

Palette is an ordered color table that contains all the color info needed for a bitmap. The index of colors starts from 0.

**Class**

**`Palette`** - this class provides ways to add and change colors for the palette.

| Method | Explanation |
| ------ | ----------- |
| `init(count:)` | Initialize a palette to store the color value. <br />**Parameter:**<br /> - `count`: decide the number of colors. The default count is 0 which means an empty palette. |
| `append(:)` | Add color to the end of a palette. <br />**Parameter:**<br /> - `color`: a color value in UInt32. |
| `subscript(index:)` | It allows you to access the color by using its index. It can used to change a specified color in palette with another color. |


Let’s say you will create a palette with 4 colors: white, balck, red, yellow. 

<img
  src={require('./img/palette.png').default}
  alt="Palette" width="240"
/>

There are two ways to get the palette:

* The first one is to create a palette with four colors in total. By default, all colors are black. Then you replace each color by using its index to the desired color. 

    ```swift
    let palette = Palette(count: 4)
    palette[0] = 0xFFFFFF
    palette[1] = 0x000000
    palette[2] = 0xFF0000
    palette[3] = 0xFFFF00
    ```

* The second method is to create an empty palette and then add the colors one by one. 

    ```swift
    let palette = Palette()
    palette.append(0xFFFFFF)
    palette.append(0x000000)
    palette.append(0xFF0000)
    palette.append(0xFFFF00)
    ```



You may find the colors directly defined by hex value are not so straightforward. You will have to think that the value of red is 0xFF0000 before setting the color. So there is a predefined struct - [`Color`](https://github.com/madmachineio/MadDisplay/blob/main/Sources/MadDisplay/Color/Color.swift) to simplify this process. It contains several commonly used colors. So the statements above could be:

```swift
let palette = Palette()
palette.append(Color.white)
palette.append(Color.black)
palette.append(Color.red)
palette.append(Color.yellow)
```
:::info
BTW, maybe you remember that the LCD needs 16-bit colors. However, the colors here are UInt32. Well, RGB888 is more frequently used. Red, green, and blue take respectively 8 bits. The library has done the conversion for you. So you don’t need to worry about it.
:::

### Bitmap

A bitmap is a collection of pixels. Each pixel corresponds to the index in a palette. Have you seen some coloring book? You use colors with corresponding numbers to paint it. The uncolored original marked with color numbers works similar to the bitmap here.

The width and height when initializing a bitmap decide its size. And the bit count decides the total amount of colors. You could set it to 1, 2, 4, 8, 16, 32. If the bit count is 1, there can be 2 possible colors for 1 pixel.

Let’s look at some of the basic API for this class:

**Class**

**`Bitmap`** - this class is used to create a bitmap and set all its pixels with indexed color.

| Method | Explanation |
| ------ | ----------- |
| `init(width:height:`<br />`bitCount:)` | Initialize a bitmap. Its width and height should not exceed those of the screen. <br />**Parameters:** <br /> - `width`: the width of the bitmap. <br /> - `height`: the height of the bitmap. <br /> - `bitCount`: the possible amount of the color. By default, all pixels adopt the first color in a palette.  |
| `setPixel(x:y:_:)` | Set a specified pixel to a color. <br />**Parameters:** <br /> - `x` and `y`: coordinates of the pixel. They start from 0, so their maximum values are width-1 and height-1 respectively. <br /> - `value`: a color index in a palette. |


Let’s create a bitmap and set pixels using the palette created above.

```swift
let bitmap = Bitmap(width: 200, height: 200, bitCount: 2)

for x in 50...150 {
    for y in 50...150 {
        bitmap.setPixel(x:x, y:y, 3)
    }
}
```

Here you create a 200x200 bitmap with 4 possible colors. By default, all pixels are set to the first color in the palette whose index is 0. So it's white. Then you will set the pixels from (50,50) to (150,150) on the middle and paint them with the fourth color (index 3) in the palette. 

<img
  src={require('./img/bitmap.png').default}
  alt="Bitmap" width="240"
/>

### Tile

Each pixel on a bitmap has an index whose color info is stored in a palette. Now it's time to paint the colors. A tile combines them together to get colored pixels.

**Class**

**`Tile`** - it sets all pixels of a bitmap to corresponding colors in the palette.

| Method | Explanation |
| ------ | ----------- |
| `init(x:y:`<br />`bitmap:palette:)` | Initialize a tile. <br />**Parameters:** <br /> - `x`, `y`: the position by defining the coordinate of the upper left corner. By default, it will start from (0,0). <br /> - `bitmap`, `tile`: the bitmap and its palette to form the tile. |
| `setX(:_)` | Move the tile horizontally. <br />**Parameter:** <br /> - `x`: the x coordinate of the position relative to its group to place the tile. It can be positive or negative. |
| `setY(:_)` | Move the tile vertically. <br />**Parameters:** <br /> - `y`: the y coordinate of the position relative to its group to place the tile. It can be positive or negative.|
| `setXY(x:y:)` | Set the position of the upper left corner of the tile to a specified coordinate. <br />**Parameters:** <br /> - `x`, `y`: the x, y-coordinate of the position relative to its group to place the tile. It can be positive or negative. |


Let’s create a tile using the bitmap and palette above:

```swift
let tile = Tile(x: 20, y: 20, bitmap: bitmap, palette: palette)
```

As the image below, the middle area is filled with yellow and the rest is white.

<img
  src={require('./img/tile.png').default}
  alt="Tile" width="480"
/>

The tile will then be added to a group. The x and y coordinates determine the tile’s position relative to its group and can be either positive or negative. As you add multiple tiles to a group, you could change the position of any tiles by setting the coordinates.

A tile’s area is always a rectangle no matter how it looks. Its position is decided by the coordinates of the upper left corner.

<img
  src={require('./img/tileOrigin.png').default}
  alt="The origin of a tile" width="480"
/>

There are some predefined shapes, such as line, rectangle, circle, etc. They are also tiles. You will look into them in more detail later.

### Group

A group is like a container. You add all tiles or other groups to it to arrange different elements. And it is what you will display on a screen at last. It allows you to control all its content together, for example, resize them, move them, etc. This is quite like that in the photo or video editing software, you group the elements to organize your work and change them more easily.

:::note
A tile or a group added to a new group should be unique and be added once, or there will be errors.
:::

**Class**

**`Group`** - it allows you to create a group to manage the elements like tiles or groups. 

| Method | Explanation |
| ------ | ----------- |
| `init(x:y:scale:)` | Initialize a group. <br />**Parameters:** <br /> - `x` and `y`: the position of the group on the screen. <br /> - `scale`: the scale to resize the group. By default, it’s 1, which means the original size. Its value is always an integer and should not be smaller than 1. |
| `append(_ group:)` | Add a new group to the group. It will overlap the elements you added before.  <br />**Parameter:** <br /> - group: a group to be added. |
| `append(_ tile:)` | Add a new tile to the group. It will overlap the elements you added before.  <br />**Parameter:** <br /> - tile: a tile to be added. |

```swift
let group = Group()
group.append(tile)
```

It will add the tile to the group. The group is placed on (0,0) by default. While the tile is set to (20,20) relative to group. So the display are as below:

<img
  src={require('./img/group.png').default}
  alt="Group" width="240"
/>

## Display

And now it’s time for the display. There is a class called `MadDisplay` that you will use to display the group above.

**Class**

**`MadDisplay`** - it allows you to display the specified group on a screen.

| Method | Explanation |
| ------ | ----------- |
| `init(screen:colorSpace:)` | Initialize a display and get the screen ready. <br />**Parameters:** <br /> - `screen`: the screen you will use to display the image. It adopts a protocol, and so does the screen in your kit.<br />- `colorSpace`: it decides how the pixels on the screen are displayed, including color depth, etc. It is nil, so it will adopt the setting in the screen instance. |
| `update(_:)` | Show the group on the screen. Every time there is a change in the group, you need to update again to show on the screen. <br />**Parameter:** <br /> - `group`: the group to be displayed. |


```swift
let spi = SPI(Id.SPI0, speed: 30_000_000)
let cs = DigitalOut(Id.D9)
let dc = DigitalOut(Id.D10)
let rst = DigitalOut(Id.D14)
let bl = DigitalOut(Id.D2)

let screen = ST7789(spi: spi, cs: cs, dc: dc, rst: rst, bl: bl, rotation: .angle90)

let display = MadDisplay(screen: screen)

display.update(group)
```

You need to initialize the screen and pass it to `MadDisplay`. After updating the content, the screen shows the group.

:::important
Any elements added or changed in a group will not show on screen automatically. You need to update the display again in order to see the changes.
:::
