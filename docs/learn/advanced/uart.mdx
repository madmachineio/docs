---
title: UART
description: Learn how to
---

# UART



**Learning goals**

* Know about parallel and serial communication.
* Distinguish between synchronous and asynchronous communication.
* Learn about the UART protocol.
* Understand the usage of USB-Serial converter.


## üî∏Background

### Dive deeper into communication

**Parallel and Serial communication**

To recap quickly, communication protocols are a set of rules that dictate how data is exchanged between devices. Typically, data is represented as a sequence of 0s and 1s, which are transmitted as digital signals between devices using different types of communication. 

Depending on **how these bits are sent**, communication can be typically categorized as either **parallel or serial**.


|                | Parallel communication                                       | Serial communication                                                       |
| -------------- | ------------------------------------------------------------ | -------------------------------------------------------------------------- |
| Transmission   | multiple bits sent at the same time over multiple data lines | bits are transmitted one after another over a single communication channel |
| Example        | communication between a CPU and memory                       | I2C, SPI, UART                                                             |
| Characteristic | allows high-speed data transfer                              | requires fewer wires                                                       |

<img
  src={require('./img/serialParallel.png').default}
  alt="" width="480"
/>

**Synchronous and Asynchronous communication**

If you are a software programmer, you may be familiar with the terms Synchronous and Asynchronous. However, in this context, we are referring to Synchronous and Asynchronous communication protocols. The primary difference between synchronous and asynchronous communication protocols lies in **the use of a clock signal**.

I2C and SPI are both examples of **synchronous communication** protocols. In synchronous communication, 
* The master device generates a **clock signal** to synchronize the data transmission between the master and slave devices.
* The clock signal specifies the duration of each bit and the rate at which bits are transmitted. 
* The data is typically read or sent at the rising or falling edge of the clock signal.

In **asynchronous communication** protocols like UART, 
* There is **no clock signal** to synchronize the transmission of data. 
* Instead, each data stream is accompanied by **start and stop bits** that indicate the beginning and end of the data transmission. 
* The transmitter and receiver independently calculate the timing of each bit based on **a predefined baud rate**.

<img
  src={require('./img/synchronous.png').default}
  alt="" width="480"
/>


### What is UART?

UART stands for Universal Asynchronous Receiver-Transmitter, which means it is a type of serial communication protocol that uses an asynchronous method for transmitting and receiving data between two devices.



**‚ùñ UART bus**

The UART bus consists of a Transmitter (TX) and Receiver (RX), which are used for data transmission between two devices.
The TX line of one device should be connected to the RX line of the other device, and vice versa. This allows the two devices to transmit and receive data to and from each other.

<img
  src={require('./img/uartBus.png').default}
  alt="" width="480"
/>

**‚ùñ Data transmission**

UART communication is asynchronous, which means that the transmitter and receiver don't share a clock signal to synchronize their actions. 

Thus, the start and stop bits are necessary, which allows the receiving device to synchronize its internal clock with the data stream and accurately interpret the data being transmitted.


In UART communication, data is transmitted in packets. Each packet consists of several components: 
* The **start bit** is the first component to signal the beginning of the transmission.
* The **data frame** follows the start bit and contains the actual data (5 - 9 bits) being transmitted. It is typically composed of 8 bits.
* If parity is used, an additional **parity bit** is added after the data frame to detect errors in the transmission. It counts the number of 1s in the data frame and can be even, odd, or none.
* Finally, **stop bit**(s) is added at the end of the packet to signal the end of the transmission. The stop bit is always a logical high level. The number of stop bits can be one or two.

The most common configuration is 8 data bits, 1 stop bit, and no parity bit.


<img
  src={require('./img/uartData.png').default}
  alt="" width="480"
/>

**‚ùñ Baud rate**

In order to accurately interpret the data being transmitted, both the transmitter and receiver must use the same baud rate. **Baud rate** is the **number of symbols** transmitted over a communication channel **per second**, typically expressed in bits per second (bps) in this case.

If the baud rates do not match, the receiver may interpret the data incorrectly, resulting in errors in the received data. For example, if the transmitter uses 9600 baud rate while the receiver uses 19200 baud rate, the receiver may sample the data at a different rate than it is being transmitted, causing it to misinterpret the data.

<img
  src={require('./img/uartBaudrate.png').default}
  alt="" width="960"
/>

Some common baud rates used in UART communication are 9600, 19200, 38400, 57600, 115200...


### Peripheral - UART

A UART peripheral is a built-in **hardware** module on a microcontroller that **provides the functionality of UART communication**.


When configuring a UART interface, you typically configure the corresponding registers in the UART peripheral to **set the baud rate, number of data bits, parity, and stop bits for data transmission**. [`SwiftIO`](https://madmachineio.github.io/SwiftIO/documentation/swiftio/uart) framework provides an abstraction layer for the UART functionality, so these configurations can be easily changed in code.

Besides, UART uses a **receive buffer** to temporarily store incoming data. When new data is received, it will be stored in this buffer. You can simply use the provided API to read data from the buffer. Its size can be configured when initializing a UART interface. It's important to make sure **the buffer size is large enough** to hold the maximum amount of data that may be received.

## üî∏New component

### USB-Serial converter

UART is commonly used in embedded systems and other electronic devices. However, many **modern computers and devices do not have built-in UART interfaces**. This is where the USB-Serial converter comes in. 

The USB-Serial converter typically includes **a USB connector and a UART interface**: it plugs into a USB port on the host device (e.g. a computer) and the UART interface is connected to the target device (e.g. a microcontroller). It takes the serial data from a microcontroller and converts it into USB data that can be understood by a computer, and vice versa. 

<img
  src={require('./img/USBSerial.png').default}
  alt="" width="960"
/>

When you connect it to a computer, it appears as a virtual COM port. To use this port, you need to **install the appropriate driver** for the converter on your computer. The driver allows the computer to recognize the converter and establish a connection between the USB host device and the UART device. Once the driver is installed, the computer can detect and manage the converter as a serial port device. 

To monitor the communication between them, a **serial monitor** program can be used. This program allows you to view the messages transmitted between the two devices and can display the data in various formats, such as ASCII or hexadecimal. It is usually used in embedded systems development to debug and troubleshoot communication between devices. 

The SwiftIO Feather board also has a built-in USB-Serial converter. Therefore, you can connect the board directly to your computer via USB and communicate with it over a serial port.

## üî∏New concept

### ASCII

ASCII stands for American Standard Code for Information Interchange and is a character encoding standard used for representing text in computers and other devices. 

ASCII uses a 7-bit binary code to represent 128 characters: the first 32 codes are non-printable control characters, while the remaining 95 codes represent printable characters, such as letters, numbers, and symbols. 

The ASCII code for a character can be represented in binary or hexadecimal format. For example, the ASCII code for the uppercase letter "A" is 65 in decimal, 1000001 in binary, and 41 in hexadecimal.

When data is transmitted over a serial communication link, it is often encoded in ASCII format for ease of interpretation. This allows the data to be easily read and understood by humans. However, as ASCII is a 7-bit encoding, some applications use extended ASCII or other encoding systems that can handle 8-bit characters or support international characters.

## üî∏Circuit - UART-Serial converter module



:::note
The circuits above are simplified versions for your reference.
:::


## üî∏API


**Class**

**`UART`** - this class allows you to write and read data via the UART bus.

| Method | Explanation |
| ------ | ----------- |
|  `init(_:baudRate:`<br />`parity:stopBits:`<br />`dataBits:`<br />`readBufferLength:)`      |  initialize a UART interface. <br />**Parameter:** <br /> - `idName`: id of the UART interface that the device connects to. <br /> - `baudRate`: the baud rate for UART communication, 115200 by default. <br /> - `parity`: the parity bit to ensure the data transmission. By default, no parity bit is used. <br /> - `stopBits`: the number of stop bit, 1 bit by default. <br /> - `dataBits`: the number of data bits, 8 bits by default. <br /> - `readBufferLength`: the length of receive buffer, 64 bytes by default. Make sure it's large enough to store data. |
|  `read()`     |             |
|  `write()`    |             |


## üî∏Projects

### 1. 

